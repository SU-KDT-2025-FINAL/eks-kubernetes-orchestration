# 기본 애플리케이션 배포

## 🚀 5.1 YAML 파일을 사용한 애플리케이션 배포

### 간단한 웹 애플리케이션 배포

#### nginx Deployment 생성
```yaml
# nginx-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
  labels:
    app: nginx
spec:
  replicas: 3  # Pod 3개 실행
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.20
        ports:
        - containerPort: 80
        resources:
          requests:
            memory: "64Mi"
            cpu: "250m"
          limits:
            memory: "128Mi"
            cpu: "500m"
```

#### Service 생성으로 외부 접근 허용
```yaml
# nginx-service.yaml
apiVersion: v1
kind: Service
metadata:
  name: nginx-service
  labels:
    app: nginx
spec:
  selector:
    app: nginx
  ports:
  - port: 80
    targetPort: 80
    protocol: TCP
  type: LoadBalancer
```

### 배포 실행
```bash
# YAML 파일 생성 (위 내용을 각각 파일로 저장)
# nginx-deployment.yaml과 nginx-service.yaml 파일 생성

# Deployment 배포
kubectl apply -f nginx-deployment.yaml
# deployment.apps/nginx-deployment created

# Service 배포
kubectl apply -f nginx-service.yaml
# service/nginx-service created

# 또는 한 번에 배포
kubectl apply -f nginx-deployment.yaml -f nginx-service.yaml
```

## 📊 5.2 배포 상태 확인 및 모니터링

### 기본 상태 확인
```bash
# Deployment 상태 확인
kubectl get deployments
# NAME               READY   UP-TO-DATE   AVAILABLE   AGE
# nginx-deployment   3/3     3            3           2m

# Pod 상태 확인
kubectl get pods
# NAME                                READY   STATUS    RESTARTS   AGE
# nginx-deployment-xxxxxxxxxx-xxxxx   1/1     Running   0          2m
# nginx-deployment-xxxxxxxxxx-yyyyy   1/1     Running   0          2m
# nginx-deployment-xxxxxxxxxx-zzzzz   1/1     Running   0          2m

# Service 상태 확인
kubectl get services
# NAME            TYPE           CLUSTER-IP      EXTERNAL-IP                                                                   PORT(S)        AGE
# kubernetes      ClusterIP      10.100.0.1      <none>                                                                        443/TCP        1h
# nginx-service   LoadBalancer   10.100.123.45   a1b2c3d4e5f6g7h8-123456789.ap-northeast-2.elb.amazonaws.com                80:31234/TCP   3m
```

### 상세 정보 확인
```bash
# Deployment 상세 정보
kubectl describe deployment nginx-deployment

# Pod 상세 정보 (특정 Pod)
kubectl describe pod nginx-deployment-xxxxxxxxxx-xxxxx

# Service 상세 정보
kubectl describe service nginx-service

# 모든 리소스 한 번에 확인
kubectl get all -l app=nginx
```

### 실시간 모니터링
```bash
# Pod 상태 실시간 모니터링
kubectl get pods -w

# 로그 확인
kubectl logs -f deployment/nginx-deployment

# 특정 Pod 로그 확인
kubectl logs nginx-deployment-xxxxxxxxxx-xxxxx

# 여러 Pod 로그 동시 확인
kubectl logs -l app=nginx --tail=10
```

## 🌐 5.3 외부 접근 테스트

### LoadBalancer 접근
```bash
# External IP 확인 (몇 분 정도 소요될 수 있음)
kubectl get service nginx-service
# EXTERNAL-IP가 <pending>에서 실제 URL로 변경될 때까지 대기

# 외부 접근 테스트
curl http://a1b2c3d4e5f6g7h8-123456789.ap-northeast-2.elb.amazonaws.com

# 또는 브라우저에서 접근
# http://a1b2c3d4e5f6g7h8-123456789.ap-northeast-2.elb.amazonaws.com
```

### 로드 밸런싱 확인
```bash
# 여러 번 요청하여 다른 Pod로 분산되는지 확인
for i in {1..10}; do
  curl -s http://your-loadbalancer-url | grep -o 'nginx/[0-9.]*'
done
```

## 🔄 5.4 애플리케이션 업데이트 (롤링 업데이트)

### 이미지 버전 업데이트
```bash
# nginx 버전을 1.20에서 1.21로 업데이트
kubectl set image deployment/nginx-deployment nginx=nginx:1.21

# 롤아웃 상태 확인
kubectl rollout status deployment/nginx-deployment
# deployment "nginx-deployment" successfully rolled out

# 롤아웃 히스토리 확인
kubectl rollout history deployment/nginx-deployment
```

### 롤링 업데이트 과정 관찰
```bash
# 업데이트 과정을 실시간으로 관찰
kubectl get pods -w

# 업데이트 과정에서 일어나는 일:
# 1. 새로운 Pod 생성 (nginx:1.21)
# 2. 새 Pod가 Ready 상태가 되면
# 3. 기존 Pod 하나씩 종료
# 4. 모든 Pod가 새 버전으로 교체될 때까지 반복
```

### 롤백 (필요 시)
```bash
# 이전 버전으로 롤백
kubectl rollout undo deployment/nginx-deployment

# 특정 리비전으로 롤백
kubectl rollout undo deployment/nginx-deployment --to-revision=1

# 롤백 상태 확인
kubectl rollout status deployment/nginx-deployment
```

## 📈 5.5 스케일링 (확장/축소)

### 수동 스케일링
```bash
# Pod 수를 3개에서 5개로 증가
kubectl scale deployment nginx-deployment --replicas=5

# 스케일링 결과 확인
kubectl get pods
# 새로운 Pod 2개가 추가로 생성됨

# Pod 수를 다시 2개로 감소
kubectl scale deployment nginx-deployment --replicas=2

# 감소 과정 확인
kubectl get pods -w
# 3개의 Pod가 종료됨
```

### YAML 파일 수정을 통한 스케일링
```yaml
# nginx-deployment.yaml 파일에서 replicas 값 변경
spec:
  replicas: 4  # 3에서 4로 변경
```

```bash
# 변경된 YAML 파일 적용
kubectl apply -f nginx-deployment.yaml

# 변경 사항 확인
kubectl get deployment nginx-deployment
```

## 🛠️ 5.6 다양한 애플리케이션 타입 배포

### 백엔드 API 서버 배포 예시
```yaml
# api-server-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: api-server
spec:
  replicas: 2
  selector:
    matchLabels:
      app: api-server
  template:
    metadata:
      labels:
        app: api-server
    spec:
      containers:
      - name: api-server
        image: node:16-alpine
        command: ["node"]
        args: ["-e", "const http = require('http'); const server = http.createServer((req, res) => { res.writeHead(200, {'Content-Type': 'application/json'}); res.end(JSON.stringify({message: 'Hello from API Server', pod: process.env.HOSTNAME})); }); server.listen(3000, () => console.log('Server running on port 3000'));"]
        ports:
        - containerPort: 3000
        env:
        - name: NODE_ENV
          value: "production"
---
apiVersion: v1
kind: Service
metadata:
  name: api-server-service
spec:
  selector:
    app: api-server
  ports:
  - port: 80
    targetPort: 3000
  type: LoadBalancer
```

### 데이터베이스 배포 예시 (개발용)
```yaml
# mysql-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql
spec:
  replicas: 1
  selector:
    matchLabels:
      app: mysql
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:8.0
        env:
        - name: MYSQL_ROOT_PASSWORD
          value: "password123"
        - name: MYSQL_DATABASE
          value: "testdb"
        ports:
        - containerPort: 3306
        volumeMounts:
        - name: mysql-storage
          mountPath: /var/lib/mysql
      volumes:
      - name: mysql-storage
        emptyDir: {}
---
apiVersion: v1
kind: Service
metadata:
  name: mysql-service
spec:
  selector:
    app: mysql
  ports:
  - port: 3306
    targetPort: 3306
  type: ClusterIP  # 내부에서만 접근 가능
```

## 🔍 5.7 문제 해결 및 디버깅

### 일반적인 문제 상황들

#### Pod가 Pending 상태인 경우
```bash
# Pod 상태 확인
kubectl get pods
# NAME                                READY   STATUS    RESTARTS   AGE
# nginx-deployment-xxxxxxxxxx-xxxxx   0/1     Pending   0          5m

# 상세 정보로 원인 파악
kubectl describe pod nginx-deployment-xxxxxxxxxx-xxxxx
# Events 섹션에서 원인 확인:
# - 리소스 부족 (CPU/Memory)
# - 노드 선택 조건 불만족
# - 볼륨 마운트 실패 등
```

#### Pod가 CrashLoopBackOff 상태인 경우
```bash
# 로그 확인
kubectl logs nginx-deployment-xxxxxxxxxx-xxxxx

# 이전 컨테이너 로그 확인
kubectl logs nginx-deployment-xxxxxxxxxx-xxxxx --previous

# 컨테이너 내부 접근하여 디버깅
kubectl exec -it nginx-deployment-xxxxxxxxxx-xxxxx -- /bin/bash
```

#### Service 접근이 안 되는 경우
```bash
# Service와 Pod의 라벨 매칭 확인
kubectl get service nginx-service -o yaml
kubectl get pods --show-labels

# 엔드포인트 확인
kubectl get endpoints nginx-service

# 포트 포워딩으로 직접 테스트
kubectl port-forward service/nginx-service 8080:80
# 브라우저에서 http://localhost:8080 접근
```

### 유용한 디버깅 명령어
```bash
# 클러스터 전체 이벤트 확인
kubectl get events --sort-by=.metadata.creationTimestamp

# 리소스 사용량 확인
kubectl top pods
kubectl top nodes

# 네트워크 연결 테스트
kubectl run test-pod --image=busybox --rm -it --restart=Never -- /bin/sh
# Pod 내부에서 nslookup, wget 등으로 테스트
```

## 🎯 5단계 완료 체크리스트

### 기본 배포 완료
- [ ] YAML 파일로 Deployment 생성 성공
- [ ] Service로 외부 접근 설정 성공
- [ ] LoadBalancer를 통한 외부 접근 확인
- [ ] 여러 Pod 간 로드 밸런싱 동작 확인

### 운영 기능 확인
- [ ] 롤링 업데이트 실행 및 확인
- [ ] 수동 스케일링 (확장/축소) 성공
- [ ] 애플리케이션 로그 확인 가능
- [ ] 기본적인 문제 해결 방법 숙지

### 다양한 애플리케이션 타입
- [ ] 웹 서버 (nginx) 배포 성공
- [ ] API 서버 배포 성공 (선택사항)
- [ ] 데이터베이스 배포 성공 (선택사항)

### 모니터링 및 디버깅
- [ ] kubectl을 사용한 상태 모니터링 가능
- [ ] 로그 확인 및 분석 가능
- [ ] 기본적인 문제 상황 대응 가능

## 💡 실습 팁

### 효율적인 개발 워크플로우
```bash
# 자주 사용하는 명령어들을 alias로 설정
alias k='kubectl'
alias kgp='kubectl get pods'
alias kgs='kubectl get services'
alias kgd='kubectl get deployments'

# 네임스페이스별 작업
kubectl create namespace dev
kubectl apply -f nginx-deployment.yaml -n dev
```

### YAML 파일 관리
```bash
# 여러 리소스를 하나의 파일에 작성 (--- 구분자 사용)
# all-in-one.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
# ... deployment 내용
---
apiVersion: v1
kind: Service
metadata:
  name: nginx-service
# ... service 내용
```

## 🤔 자주 묻는 질문

**Q: Pod가 여러 개 있을 때 로그를 어떻게 확인하나요?**
A: `kubectl logs -l app=nginx --tail=10`으로 라벨 기반으로 여러 Pod 로그를 동시에 확인할 수 있습니다.

**Q: 배포한 애플리케이션이 외부에서 접근되지 않아요.**
A: Service 타입이 LoadBalancer인지, External IP가 할당되었는지 확인하고, AWS 보안 그룹 설정도 점검해보세요.

**Q: 롤링 업데이트 중에 서비스가 중단되나요?**
A: 아니요. 쿠버네티스는 새 Pod가 준비된 후 기존 Pod를 종료하므로 무중단 배포가 가능합니다.

---

**다음 단계**: [07-모니터링과-로깅.md](./07-모니터링과-로깅.md)로 이동하여 애플리케이션 모니터링 방법을 학습하세요.