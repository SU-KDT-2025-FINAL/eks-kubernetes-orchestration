# 고급 기능 실습

## 🔧 7.1 ConfigMap과 Secret

### ConfigMap - 설정 정보 분리

#### ConfigMap 생성 방법들
```bash
# 1. 명령어로 직접 생성
kubectl create configmap app-config \
  --from-literal=database_url=mysql://localhost:3306/mydb \
  --from-literal=debug_mode=true \
  --from-literal=max_connections=100

# 2. 파일에서 생성
echo "database_url=mysql://localhost:3306/mydb" > app.properties
echo "debug_mode=true" >> app.properties
kubectl create configmap app-config --from-file=app.properties

# 3. YAML 파일로 생성
```

```yaml
# app-configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
data:
  database_url: "mysql://localhost:3306/mydb"
  debug_mode: "true"
  max_connections: "100"
  app.properties: |
    database_url=mysql://localhost:3306/mydb
    debug_mode=true
    max_connections=100
    log_level=info
```

#### ConfigMap 사용하기
```yaml
# configmap-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: configmap-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app: configmap-app
  template:
    metadata:
      labels:
        app: configmap-app
    spec:
      containers:
      - name: app
        image: nginx:1.20
        # 환경 변수로 사용
        env:
        - name: DATABASE_URL
          valueFrom:
            configMapKeyRef:
              name: app-config
              key: database_url
        - name: DEBUG_MODE
          valueFrom:
            configMapKeyRef:
              name: app-config
              key: debug_mode
        # 모든 키를 환경 변수로 가져오기
        envFrom:
        - configMapRef:
            name: app-config
        # 볼륨으로 마운트
        volumeMounts:
        - name: config-volume
          mountPath: /etc/config
      volumes:
      - name: config-volume
        configMap:
          name: app-config
```

### Secret - 민감한 정보 안전하게 관리

#### Secret 생성
```bash
# 1. 명령어로 직접 생성
kubectl create secret generic db-secret \
  --from-literal=username=admin \
  --from-literal=password=secretpassword123

# 2. 파일에서 생성
echo -n 'admin' > username.txt
echo -n 'secretpassword123' > password.txt
kubectl create secret generic db-secret \
  --from-file=username=username.txt \
  --from-file=password=password.txt

# 3. YAML 파일로 생성 (base64 인코딩 필요)
echo -n 'admin' | base64  # YWRtaW4=
echo -n 'secretpassword123' | base64  # c2VjcmV0cGFzc3dvcmQxMjM=
```

```yaml
# db-secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: db-secret
type: Opaque
data:
  username: YWRtaW4=  # admin (base64 encoded)
  password: c2VjcmV0cGFzc3dvcmQxMjM=  # secretpassword123 (base64 encoded)
```

#### Secret 사용하기
```yaml
# secret-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: secret-app
spec:
  replicas: 1
  selector:
    matchLabels:
      app: secret-app
  template:
    metadata:
      labels:
        app: secret-app
    spec:
      containers:
      - name: app
        image: mysql:8.0
        env:
        - name: MYSQL_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: db-secret
              key: password
        - name: MYSQL_USER
          valueFrom:
            secretKeyRef:
              name: db-secret
              key: username
        # 볼륨으로 마운트 (파일로 접근)
        volumeMounts:
        - name: secret-volume
          mountPath: /etc/secrets
          readOnly: true
      volumes:
      - name: secret-volume
        secret:
          secretName: db-secret
```

## 💾 7.2 Persistent Volume (영구 스토리지)

### EBS 볼륨을 사용한 Persistent Volume

#### StorageClass 확인
```bash
# 기본 StorageClass 확인
kubectl get storageclass
# NAME            PROVISIONER             RECLAIMPOLICY   VOLUMEBINDINGMODE      ALLOWVOLUMEEXPANSION   AGE
# gp2 (default)   kubernetes.io/aws-ebs   Delete          WaitForFirstConsumer   false                  1h
```

#### PersistentVolumeClaim 생성
```yaml
# mysql-pvc.yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
  storageClassName: gp2
```

#### PVC를 사용하는 MySQL 배포
```yaml
# mysql-with-pv.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql-persistent
spec:
  replicas: 1
  selector:
    matchLabels:
      app: mysql-persistent
  template:
    metadata:
      labels:
        app: mysql-persistent
    spec:
      containers:
      - name: mysql
        image: mysql:8.0
        env:
        - name: MYSQL_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: db-secret
              key: password
        - name: MYSQL_DATABASE
          value: "testdb"
        ports:
        - containerPort: 3306
        volumeMounts:
        - name: mysql-storage
          mountPath: /var/lib/mysql
      volumes:
      - name: mysql-storage
        persistentVolumeClaim:
          claimName: mysql-pvc
---
apiVersion: v1
kind: Service
metadata:
  name: mysql-service
spec:
  selector:
    app: mysql-persistent
  ports:
  - port: 3306
    targetPort: 3306
  type: ClusterIP
```

#### 데이터 영속성 테스트
```bash
# MySQL Pod에 접속하여 데이터 생성
kubectl exec -it deployment/mysql-persistent -- mysql -u root -p

# MySQL 내에서 테스트 데이터 생성
CREATE DATABASE testdb;
USE testdb;
CREATE TABLE users (id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(50));
INSERT INTO users (name) VALUES ('Alice'), ('Bob'), ('Charlie');
SELECT * FROM users;
exit

# Pod 삭제 후 재생성
kubectl delete pod -l app=mysql-persistent

# 새로운 Pod에서 데이터 확인
kubectl exec -it deployment/mysql-persistent -- mysql -u root -p -e "USE testdb; SELECT * FROM users;"
```

## 📈 7.3 Horizontal Pod Autoscaler (HPA)

### Metrics Server 설치 (필요 시)
```bash
# Metrics Server 설치
kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml

# 설치 확인
kubectl get pods -n kube-system | grep metrics-server
```

### CPU 기반 HPA 설정
```yaml
# cpu-intensive-app.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: cpu-app
spec:
  replicas: 1
  selector:
    matchLabels:
      app: cpu-app
  template:
    metadata:
      labels:
        app: cpu-app
    spec:
      containers:
      - name: cpu-app
        image: k8s.gcr.io/hpa-example
        ports:
        - containerPort: 80
        resources:
          requests:
            cpu: 200m
            memory: 256Mi
          limits:
            cpu: 500m
            memory: 512Mi
---
apiVersion: v1
kind: Service
metadata:
  name: cpu-app-service
spec:
  selector:
    app: cpu-app
  ports:
  - port: 80
    targetPort: 80
  type: LoadBalancer
```

#### HPA 생성
```bash
# 명령어로 HPA 생성
kubectl autoscale deployment cpu-app --cpu-percent=50 --min=1 --max=10

# 또는 YAML 파일로 생성
```

```yaml
# hpa.yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: cpu-app-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: cpu-app
  minReplicas: 1
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 50
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 70
```

#### HPA 테스트
```bash
# HPA 상태 확인
kubectl get hpa
# NAME          REFERENCE            TARGETS   MINPODS   MAXPODS   REPLICAS   AGE
# cpu-app-hpa   Deployment/cpu-app   0%/50%    1         10        1          2m

# 부하 생성 (별도 터미널에서)
kubectl run -i --tty load-generator --rm --image=busybox --restart=Never -- /bin/sh
# Pod 내에서 실행:
while true; do wget -q -O- http://cpu-app-service; done

# HPA 동작 확인 (실시간 모니터링)
kubectl get hpa -w
kubectl get pods -w
```

### 커스텀 메트릭 기반 HPA (고급)
```yaml
# custom-metrics-hpa.yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: custom-metrics-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: my-app
  minReplicas: 2
  maxReplicas: 20
  metrics:
  - type: Pods
    pods:
      metric:
        name: http_requests_per_second
      target:
        type: AverageValue
        averageValue: "100"
  - type: External
    external:
      metric:
        name: sqs_queue_length
        selector:
          matchLabels:
            queue: "my-queue"
      target:
        type: Value
        value: "10"
```

## 🌐 7.4 Ingress Controller

### AWS Load Balancer Controller 설치
```bash
# IAM 정책 생성
curl -o iam_policy.json https://raw.githubusercontent.com/kubernetes-sigs/aws-load-balancer-controller/v2.4.4/docs/install/iam_policy.json

aws iam create-policy \
    --policy-name AWSLoadBalancerControllerIAMPolicy \
    --policy-document file://iam_policy.json

# ServiceAccount 생성
eksctl create iamserviceaccount \
  --cluster=my-first-cluster \
  --namespace=kube-system \
  --name=aws-load-balancer-controller \
  --role-name "AmazonEKSLoadBalancerControllerRole" \
  --attach-policy-arn=arn:aws:iam::ACCOUNT-ID:policy/AWSLoadBalancerControllerIAMPolicy \
  --approve

# Helm으로 AWS Load Balancer Controller 설치
helm repo add eks https://aws.github.io/eks-charts
helm repo update

helm install aws-load-balancer-controller eks/aws-load-balancer-controller \
  -n kube-system \
  --set clusterName=my-first-cluster \
  --set serviceAccount.create=false \
  --set serviceAccount.name=aws-load-balancer-controller
```

### 기본 Ingress 설정
```yaml
# basic-ingress.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: basic-ingress
  annotations:
    kubernetes.io/ingress.class: alb
    alb.ingress.kubernetes.io/scheme: internet-facing
    alb.ingress.kubernetes.io/target-type: ip
spec:
  rules:
  - http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: nginx-service
            port:
              number: 80
      - path: /api
        pathType: Prefix
        backend:
          service:
            name: api-service
            port:
              number: 80
```

### 도메인 기반 라우팅
```yaml
# domain-based-ingress.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: domain-ingress
  annotations:
    kubernetes.io/ingress.class: alb
    alb.ingress.kubernetes.io/scheme: internet-facing
    alb.ingress.kubernetes.io/target-type: ip
    alb.ingress.kubernetes.io/certificate-arn: arn:aws:acm:region:account:certificate/cert-id
    alb.ingress.kubernetes.io/listen-ports: '[{"HTTP": 80}, {"HTTPS":443}]'
    alb.ingress.kubernetes.io/ssl-redirect: '443'
spec:
  rules:
  - host: api.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: api-service
            port:
              number: 80
  - host: web.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: web-service
            port:
              number: 80
```

## 🔒 7.5 네트워크 정책 (Network Policy)

### Calico 설치 (네트워크 정책 지원)
```bash
# Calico 설치
kubectl apply -f https://raw.githubusercontent.com/aws/amazon-vpc-cni-k8s/master/config/master/calico-operator.yaml
kubectl apply -f https://raw.githubusercontent.com/aws/amazon-vpc-cni-k8s/master/config/master/calico-crs.yaml
```

### 기본 네트워크 정책
```yaml
# network-policy.yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: deny-all
  namespace: default
spec:
  podSelector: {}
  policyTypes:
  - Ingress
  - Egress
---
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-nginx
  namespace: default
spec:
  podSelector:
    matchLabels:
      app: nginx
  policyTypes:
  - Ingress
  ingress:
  - from:
    - podSelector:
        matchLabels:
          app: frontend
    ports:
    - protocol: TCP
      port: 80
---
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-database
  namespace: default
spec:
  podSelector:
    matchLabels:
      app: mysql
  policyTypes:
  - Ingress
  ingress:
  - from:
    - podSelector:
        matchLabels:
          app: backend
    ports:
    - protocol: TCP
      port: 3306
```

## 🎯 7단계 완료 체크리스트

### ConfigMap과 Secret
- [ ] ConfigMap 생성 및 환경 변수로 사용 성공
- [ ] ConfigMap을 볼륨으로 마운트하여 파일로 사용 성공
- [ ] Secret 생성 및 민감한 정보 관리 성공
- [ ] Secret을 환경 변수와 볼륨으로 사용 성공

### Persistent Volume
- [ ] PVC 생성 및 Pod에 연결 성공
- [ ] 데이터 영속성 테스트 완료 (Pod 재시작 후 데이터 유지 확인)
- [ ] EBS 볼륨이 AWS 콘솔에서 확인됨

### Horizontal Pod Autoscaler
- [ ] Metrics Server 설치 및 동작 확인
- [ ] CPU 기반 HPA 설정 및 테스트 성공
- [ ] 부하 증가 시 Pod 자동 확장 확인
- [ ] 부하 감소 시 Pod 자동 축소 확인

### Ingress Controller
- [ ] AWS Load Balancer Controller 설치 성공
- [ ] 기본 Ingress 설정 및 ALB 생성 확인
- [ ] 경로 기반 라우팅 동작 확인
- [ ] 도메인 기반 라우팅 설정 (선택사항)

### 네트워크 정책 (선택사항)
- [ ] 네트워크 정책 설정 및 트래픽 제어 확인

## 💡 실습 팁

### 리소스 관리
```bash
# 모든 실습 리소스를 네임스페이스로 분리
kubectl create namespace advanced-features
kubectl apply -f . -n advanced-features

# 실습 완료 후 정리
kubectl delete namespace advanced-features
```

### 문제 해결
```bash
# PVC가 Pending 상태인 경우
kubectl describe pvc mysql-pvc
# Events 섹션에서 원인 확인

# HPA가 동작하지 않는 경우
kubectl describe hpa cpu-app-hpa
# Metrics Server 상태 확인
kubectl get pods -n kube-system | grep metrics-server

# Ingress가 ALB를 생성하지 않는 경우
kubectl describe ingress basic-ingress
# AWS Load Balancer Controller 로그 확인
kubectl logs -n kube-system deployment/aws-load-balancer-controller
```

## 🤔 자주 묻는 질문

**Q: ConfigMap과 Secret의 차이점은 무엇인가요?**
A: ConfigMap은 일반 설정 정보를, Secret은 비밀번호 같은 민감한 정보를 저장합니다. Secret은 base64로 인코딩되고 더 엄격한 접근 제어가 적용됩니다.

**Q: PVC를 삭제하면 데이터도 함께 삭제되나요?**
A: StorageClass의 reclaimPolicy에 따라 다릅니다. 기본값인 'Delete'는 PVC 삭제 시 볼륨도 삭제하고, 'Retain'은 볼륨을 보존합니다.

**Q: HPA가 너무 자주 스케일링해서 불안정해요.**
A: `--horizontal-pod-autoscaler-downscale-stabilization` 옵션으로 축소 안정화 시간을 조정하거나, behavior 설정을 통해 스케일링 속도를 제어할 수 있습니다.

---

**다음 단계**: [09-실전-프로젝트.md](./09-실전-프로젝트.md)로 이동하여 종합적인 실전 프로젝트를 진행하세요.