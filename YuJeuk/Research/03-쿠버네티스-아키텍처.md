# 쿠버네티스 아키텍처 이해

## 🏗️ 2.1 클러스터 구조 개요

### 쿠버네티스 클러스터란?
- 여러 대의 서버(노드)가 하나의 시스템처럼 동작하는 환경
- **Master Node(Control Plane)**: 클러스터를 관리하는 두뇌 역할
- **Worker Node**: 실제 애플리케이션(Pod)이 실행되는 곳

```
┌─────────────────────────────────────────────────────────┐
│                 Kubernetes Cluster                      │
├─────────────────────────────────────────────────────────┤
│  Master Node (Control Plane)                           │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────────────┐│
│  │ API Server  │ │    etcd     │ │     Scheduler       ││
│  └─────────────┘ └─────────────┘ └─────────────────────┘│
│  ┌─────────────────────────────────────────────────────┐│
│  │           Controller Manager                        ││
│  └─────────────────────────────────────────────────────┘│
├─────────────────────────────────────────────────────────┤
│  Worker Node 1        │  Worker Node 2                 │
│  ┌─────────────────┐   │  ┌─────────────────┐           │
│  │     kubelet     │   │  │     kubelet     │           │
│  ├─────────────────┤   │  ├─────────────────┤           │
│  │   kube-proxy    │   │  │   kube-proxy    │           │
│  ├─────────────────┤   │  ├─────────────────┤           │
│  │Container Runtime│   │  │Container Runtime│           │
│  │   (Docker)      │   │  │   (Docker)      │           │
│  └─────────────────┘   │  └─────────────────┘           │
│  ┌─────┐ ┌─────┐       │  ┌─────┐ ┌─────┐               │
│  │Pod 1│ │Pod 2│       │  │Pod 3│ │Pod 4│               │
│  └─────┘ └─────┘       │  └─────┘ └─────┘               │
└─────────────────────────────────────────────────────────┘
```

## 🧠 2.2 Master Node (Control Plane) 컴포넌트

### API Server - 모든 요청의 중앙 처리소
```bash
# 모든 kubectl 명령어는 API Server로 전달됩니다
kubectl get pods  # → API Server → etcd에서 Pod 정보 조회
kubectl apply -f deployment.yaml  # → API Server → 요청 처리
```

**API Server의 역할:**
- 모든 REST API 요청의 진입점
- 인증 및 권한 검사
- etcd와의 유일한 통신 창구
- 다른 컴포넌트들 간의 통신 중계

**실생활 비유:** 회사의 접수처, 모든 업무 요청이 여기를 거쳐감

### etcd - 클러스터의 기억 저장소
```
etcd에 저장되는 정보들:
- 클러스터 설정 정보
- Pod, Service, Deployment 등의 상태
- 네트워크 설정
- 보안 정책
```

**etcd의 특징:**
- 분산 키-값 저장소
- 클러스터의 모든 상태 정보 저장
- 고가용성을 위해 보통 3개 이상의 인스턴스로 구성
- 백업이 매우 중요 (etcd가 손상되면 클러스터 전체가 마비)

**실생활 비유:** 회사의 중앙 데이터베이스, 모든 중요한 정보가 저장됨

### Scheduler - 똑똑한 배치 담당자
```yaml
# Scheduler가 고려하는 요소들
spec:
  containers:
  - name: my-app
    image: my-app:1.0
    resources:
      requests:
        memory: "256Mi"
        cpu: "250m"
      limits:
        memory: "512Mi"
        cpu: "500m"
```

**Scheduler의 역할:**
- 새로 생성된 Pod를 어느 Worker Node에 배치할지 결정
- 노드의 리소스 상황 고려 (CPU, 메모리, 디스크)
- Pod의 요구사항과 제약조건 고려
- 노드의 라벨과 Pod의 nodeSelector 매칭

**배치 결정 과정:**
1. 사용 가능한 노드 필터링
2. 각 노드에 점수 매기기
3. 가장 적합한 노드 선택

**실생활 비유:** 호텔 예약 시스템, 고객 요구사항에 맞는 최적의 방 배정

### Controller Manager - 상태 관리의 달인
```bash
# Controller Manager가 관리하는 컨트롤러들
- Deployment Controller: Deployment 상태 관리
- ReplicaSet Controller: Pod 복제본 수 관리
- Service Controller: Service 엔드포인트 관리
- Node Controller: 노드 상태 모니터링
```

**Controller Manager의 역할:**
- 다양한 컨트롤러들을 실행하고 관리
- 현재 상태와 원하는 상태를 지속적으로 비교
- 차이가 발생하면 원하는 상태로 맞추기 위한 작업 수행

**Control Loop 예시:**
```
1. 원하는 상태: nginx Pod 3개
2. 현재 상태: nginx Pod 2개 (1개가 죽음)
3. 차이 발견: 1개 부족
4. 조치: 새로운 nginx Pod 1개 생성
5. 다시 확인: nginx Pod 3개 → 원하는 상태 달성
```

**실생활 비유:** 품질관리팀, 지속적으로 상태를 점검하고 문제 발생 시 조치

## 👷 2.3 Worker Node 컴포넌트

### kubelet - 각 노드의 관리자
```bash
# kubelet이 하는 일들
- Pod 생성 및 관리
- 컨테이너 상태 모니터링
- API Server에 노드 상태 보고
- 볼륨 마운트 관리
```

**kubelet의 역할:**
- 각 Worker Node에서 실행되는 에이전트
- API Server로부터 Pod 스펙을 받아서 실행
- 컨테이너 런타임과 통신하여 컨테이너 관리
- 노드와 Pod의 상태를 API Server에 주기적으로 보고

**실생활 비유:** 각 지점의 점장, 본사 지시를 받아 현장에서 실행

### kube-proxy - 네트워크 프록시
```bash
# kube-proxy가 관리하는 네트워크 규칙
iptables -t nat -L  # iptables 규칙 확인 (Linux)
```

**kube-proxy의 역할:**
- Service의 가상 IP를 실제 Pod IP로 연결
- 로드 밸런싱 규칙 설정
- 네트워크 트래픽 라우팅
- iptables 또는 IPVS를 사용하여 네트워크 규칙 관리

**동작 예시:**
```
1. 클라이언트가 Service IP:80으로 요청
2. kube-proxy가 설정한 규칙에 따라
3. 실제 Pod IP:80으로 트래픽 전달
4. 여러 Pod가 있으면 라운드로빈으로 분산
```

**실생활 비유:** 교환원, 외부 전화를 적절한 내선으로 연결

### Container Runtime - 컨테이너 실행 엔진
```bash
# 주요 컨테이너 런타임들
- Docker: 가장 널리 사용됨
- containerd: Docker에서 분리된 경량 런타임
- CRI-O: 쿠버네티스 전용 런타임
```

**Container Runtime의 역할:**
- 실제 컨테이너 이미지 다운로드
- 컨테이너 생성, 시작, 중지, 삭제
- 컨테이너 리소스 관리
- kubelet과 CRI(Container Runtime Interface)를 통해 통신

## 🔄 2.4 전체 동작 흐름 예시

### Pod 생성 과정
```bash
kubectl apply -f nginx-pod.yaml
```

**1단계: 요청 접수**
```
kubectl → API Server → 인증/권한 검사 → etcd에 Pod 정보 저장
```

**2단계: 스케줄링**
```
Scheduler → etcd에서 미배치 Pod 발견 → 적절한 노드 선택 → etcd 업데이트
```

**3단계: Pod 실행**
```
kubelet → API Server에서 자신의 노드에 배치된 Pod 확인 → Container Runtime에 컨테이너 생성 요청
```

**4단계: 네트워크 설정**
```
kube-proxy → Service 규칙 업데이트 → 네트워크 라우팅 설정
```

**5단계: 상태 보고**
```
kubelet → Pod 상태를 API Server에 보고 → etcd 업데이트
```

## 🎯 2단계 완료 체크리스트

### 이론 이해
- [ ] Master Node와 Worker Node의 역할 차이를 설명할 수 있다
- [ ] API Server, etcd, Scheduler, Controller Manager의 역할을 각각 설명할 수 있다
- [ ] kubelet, kube-proxy, Container Runtime의 역할을 설명할 수 있다
- [ ] Pod 생성 시 각 컴포넌트가 어떤 순서로 동작하는지 이해했다

### 실습 확인
```bash
# 클러스터 컴포넌트 상태 확인
kubectl get componentstatuses

# 시스템 Pod 확인 (Master Node 컴포넌트들)
kubectl get pods -n kube-system

# 노드 상세 정보 확인
kubectl describe nodes
```

## 🤔 자주 묻는 질문

**Q: Master Node에도 애플리케이션 Pod를 배치할 수 있나요?**
A: 기술적으로는 가능하지만, 보통 Master Node는 관리 전용으로 사용합니다. 프로덕션에서는 권장하지 않아요.

**Q: etcd가 손상되면 어떻게 되나요?**
A: 클러스터의 모든 상태 정보가 사라져서 클러스터가 마비됩니다. 정기적인 백업이 필수입니다.

**Q: Worker Node가 다운되면 그 위의 Pod는 어떻게 되나요?**
A: Controller Manager가 감지하고 다른 정상적인 노드에 Pod를 재생성합니다.

---

**다음 단계**: [04-AWS-EKS-이해.md](./04-AWS-EKS-이해.md)로 이동하여 AWS EKS의 특징과 장점을 학습하세요.