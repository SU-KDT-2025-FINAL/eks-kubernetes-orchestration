# 실전 프로젝트

## 🏗️ 8.1 프로젝트 개요: 마이크로서비스 블로그 플랫폼

### 프로젝트 구조
```
Blog Platform Architecture
├── Frontend (React)
│   ├── 사용자 인터페이스
│   └── 정적 파일 서빙
├── API Gateway (Nginx)
│   ├── 라우팅 및 로드 밸런싱
│   └── SSL 종료
├── Backend Services
│   ├── User Service (Node.js)
│   ├── Post Service (Python)
│   └── Comment Service (Go)
├── Database Layer
│   ├── PostgreSQL (사용자 데이터)
│   ├── MongoDB (포스트 데이터)
│   └── Redis (캐시)
└── Monitoring & Logging
    ├── Prometheus
    ├── Grafana
    └── ELK Stack
```

### 학습 목표
- 실제 마이크로서비스 아키텍처 구현
- 서비스 간 통신 및 데이터 관리
- CI/CD 파이프라인 구축
- 모니터링 및 로깅 시스템 구축
- 보안 및 네트워크 정책 적용

## 🚀 8.2 단계별 구현

### Phase 1: 기본 인프라 구성

#### 네임스페이스 및 기본 설정
```yaml
# namespaces.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: blog-platform
  labels:
    name: blog-platform
---
apiVersion: v1
kind: Namespace
metadata:
  name: blog-monitoring
  labels:
    name: blog-monitoring
---
apiVersion: v1
kind: Namespace
metadata:
  name: blog-database
  labels:
    name: blog-database
```

#### ConfigMap 및 Secret 설정
```yaml
# config-secrets.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
  namespace: blog-platform
data:
  NODE_ENV: "production"
  API_VERSION: "v1"
  CORS_ORIGIN: "*"
  LOG_LEVEL: "info"
  REDIS_HOST: "redis-service.blog-database.svc.cluster.local"
  POSTGRES_HOST: "postgres-service.blog-database.svc.cluster.local"
  MONGODB_HOST: "mongodb-service.blog-database.svc.cluster.local"
---
apiVersion: v1
kind: Secret
metadata:
  name: db-secrets
  namespace: blog-platform
type: Opaque
data:
  postgres-user: YmxvZ3VzZXI=  # bloguser
  postgres-password: c2VjdXJlcGFzcw==  # securepass
  mongodb-user: YmxvZ3VzZXI=  # bloguser
  mongodb-password: c2VjdXJlcGFzcw==  # securepass
  redis-password: cmVkaXNwYXNz  # redispass
  jwt-secret: bXlzdXBlcnNlY3JldGp3dGtleQ==  # mysupersecretjwtkey
```

### Phase 2: 데이터베이스 레이어 구축

#### PostgreSQL 배포 (사용자 서비스용)
```yaml
# postgres.yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: postgres-pvc
  namespace: blog-database
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
  storageClassName: gp2
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: postgres
  namespace: blog-database
spec:
  replicas: 1
  selector:
    matchLabels:
      app: postgres
  template:
    metadata:
      labels:
        app: postgres
    spec:
      containers:
      - name: postgres
        image: postgres:13
        env:
        - name: POSTGRES_DB
          value: "blogdb"
        - name: POSTGRES_USER
          valueFrom:
            secretKeyRef:
              name: db-secrets
              key: postgres-user
        - name: POSTGRES_PASSWORD
          valueFrom:
            secretKeyRef:
              name: db-secrets
              key: postgres-password
        ports:
        - containerPort: 5432
        volumeMounts:
        - name: postgres-storage
          mountPath: /var/lib/postgresql/data
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
      volumes:
      - name: postgres-storage
        persistentVolumeClaim:
          claimName: postgres-pvc
---
apiVersion: v1
kind: Service
metadata:
  name: postgres-service
  namespace: blog-database
spec:
  selector:
    app: postgres
  ports:
  - port: 5432
    targetPort: 5432
  type: ClusterIP
```

#### MongoDB 배포 (포스트 서비스용)
```yaml
# mongodb.yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mongodb-pvc
  namespace: blog-database
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
  storageClassName: gp2
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mongodb
  namespace: blog-database
spec:
  replicas: 1
  selector:
    matchLabels:
      app: mongodb
  template:
    metadata:
      labels:
        app: mongodb
    spec:
      containers:
      - name: mongodb
        image: mongo:5.0
        env:
        - name: MONGO_INITDB_ROOT_USERNAME
          valueFrom:
            secretKeyRef:
              name: db-secrets
              key: mongodb-user
        - name: MONGO_INITDB_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: db-secrets
              key: mongodb-password
        - name: MONGO_INITDB_DATABASE
          value: "blogdb"
        ports:
        - containerPort: 27017
        volumeMounts:
        - name: mongodb-storage
          mountPath: /data/db
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
      volumes:
      - name: mongodb-storage
        persistentVolumeClaim:
          claimName: mongodb-pvc
---
apiVersion: v1
kind: Service
metadata:
  name: mongodb-service
  namespace: blog-database
spec:
  selector:
    app: mongodb
  ports:
  - port: 27017
    targetPort: 27017
  type: ClusterIP
```

#### Redis 배포 (캐시용)
```yaml
# redis.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: redis
  namespace: blog-database
spec:
  replicas: 1
  selector:
    matchLabels:
      app: redis
  template:
    metadata:
      labels:
        app: redis
    spec:
      containers:
      - name: redis
        image: redis:6.2-alpine
        command:
        - redis-server
        - --requirepass
        - $(REDIS_PASSWORD)
        env:
        - name: REDIS_PASSWORD
          valueFrom:
            secretKeyRef:
              name: db-secrets
              key: redis-password
        ports:
        - containerPort: 6379
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
---
apiVersion: v1
kind: Service
metadata:
  name: redis-service
  namespace: blog-database
spec:
  selector:
    app: redis
  ports:
  - port: 6379
    targetPort: 6379
  type: ClusterIP
```

### Phase 3: 백엔드 마이크로서비스 구축

#### User Service (Node.js)
```yaml
# user-service.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: user-service
  namespace: blog-platform
spec:
  replicas: 2
  selector:
    matchLabels:
      app: user-service
  template:
    metadata:
      labels:
        app: user-service
    spec:
      containers:
      - name: user-service
        image: node:16-alpine
        command: ["sh", "-c"]
        args:
        - |
          cat > package.json << 'EOF'
          {
            "name": "user-service",
            "version": "1.0.0",
            "main": "server.js",
            "dependencies": {
              "express": "^4.18.0",
              "pg": "^8.7.0",
              "bcrypt": "^5.0.0",
              "jsonwebtoken": "^8.5.0",
              "cors": "^2.8.0"
            }
          }
          EOF
          
          cat > server.js << 'EOF'
          const express = require('express');
          const { Pool } = require('pg');
          const bcrypt = require('bcrypt');
          const jwt = require('jsonwebtoken');
          const cors = require('cors');
          
          const app = express();
          app.use(cors());
          app.use(express.json());
          
          const pool = new Pool({
            host: process.env.POSTGRES_HOST,
            user: process.env.POSTGRES_USER,
            password: process.env.POSTGRES_PASSWORD,
            database: 'blogdb',
            port: 5432,
          });
          
          // Health check
          app.get('/health', (req, res) => {
            res.json({ status: 'healthy', service: 'user-service' });
          });
          
          // User registration
          app.post('/api/users/register', async (req, res) => {
            try {
              const { username, email, password } = req.body;
              const hashedPassword = await bcrypt.hash(password, 10);
              
              const result = await pool.query(
                'INSERT INTO users (username, email, password) VALUES ($1, $2, $3) RETURNING id, username, email',
                [username, email, hashedPassword]
              );
              
              res.status(201).json(result.rows[0]);
            } catch (error) {
              res.status(500).json({ error: error.message });
            }
          });
          
          // User login
          app.post('/api/users/login', async (req, res) => {
            try {
              const { email, password } = req.body;
              
              const result = await pool.query('SELECT * FROM users WHERE email = $1', [email]);
              if (result.rows.length === 0) {
                return res.status(401).json({ error: 'Invalid credentials' });
              }
              
              const user = result.rows[0];
              const validPassword = await bcrypt.compare(password, user.password);
              
              if (!validPassword) {
                return res.status(401).json({ error: 'Invalid credentials' });
              }
              
              const token = jwt.sign({ userId: user.id }, process.env.JWT_SECRET);
              res.json({ token, user: { id: user.id, username: user.username, email: user.email } });
            } catch (error) {
              res.status(500).json({ error: error.message });
            }
          });
          
          const PORT = process.env.PORT || 3001;
          app.listen(PORT, () => {
            console.log(`User service running on port ${PORT}`);
          });
          EOF
          
          npm install
          node server.js
        env:
        - name: POSTGRES_HOST
          valueFrom:
            configMapKeyRef:
              name: app-config
              key: POSTGRES_HOST
        - name: POSTGRES_USER
          valueFrom:
            secretKeyRef:
              name: db-secrets
              key: postgres-user
        - name: POSTGRES_PASSWORD
          valueFrom:
            secretKeyRef:
              name: db-secrets
              key: postgres-password
        - name: JWT_SECRET
          valueFrom:
            secretKeyRef:
              name: db-secrets
              key: jwt-secret
        ports:
        - containerPort: 3001
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
        livenessProbe:
          httpGet:
            path: /health
            port: 3001
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 3001
          initialDelaySeconds: 5
          periodSeconds: 5
---
apiVersion: v1
kind: Service
metadata:
  name: user-service
  namespace: blog-platform
spec:
  selector:
    app: user-service
  ports:
  - port: 80
    targetPort: 3001
  type: ClusterIP
```

#### Post Service (Python/FastAPI)
```yaml
# post-service.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: post-service
  namespace: blog-platform
spec:
  replicas: 2
  selector:
    matchLabels:
      app: post-service
  template:
    metadata:
      labels:
        app: post-service
    spec:
      containers:
      - name: post-service
        image: python:3.9-slim
        command: ["sh", "-c"]
        args:
        - |
          pip install fastapi uvicorn pymongo python-multipart
          
          cat > main.py << 'EOF'
          from fastapi import FastAPI, HTTPException
          from pymongo import MongoClient
          from bson import ObjectId
          import os
          from datetime import datetime
          
          app = FastAPI()
          
          # MongoDB connection
          client = MongoClient(f"mongodb://{os.getenv('MONGODB_USER')}:{os.getenv('MONGODB_PASSWORD')}@{os.getenv('MONGODB_HOST')}:27017/")
          db = client.blogdb
          posts_collection = db.posts
          
          @app.get("/health")
          def health_check():
              return {"status": "healthy", "service": "post-service"}
          
          @app.post("/api/posts")
          def create_post(post_data: dict):
              post_data["created_at"] = datetime.utcnow()
              post_data["updated_at"] = datetime.utcnow()
              result = posts_collection.insert_one(post_data)
              return {"id": str(result.inserted_id), "message": "Post created successfully"}
          
          @app.get("/api/posts")
          def get_posts():
              posts = list(posts_collection.find())
              for post in posts:
                  post["_id"] = str(post["_id"])
              return posts
          
          @app.get("/api/posts/{post_id}")
          def get_post(post_id: str):
              post = posts_collection.find_one({"_id": ObjectId(post_id)})
              if post:
                  post["_id"] = str(post["_id"])
                  return post
              raise HTTPException(status_code=404, detail="Post not found")
          
          @app.put("/api/posts/{post_id}")
          def update_post(post_id: str, post_data: dict):
              post_data["updated_at"] = datetime.utcnow()
              result = posts_collection.update_one(
                  {"_id": ObjectId(post_id)}, 
                  {"$set": post_data}
              )
              if result.modified_count:
                  return {"message": "Post updated successfully"}
              raise HTTPException(status_code=404, detail="Post not found")
          
          @app.delete("/api/posts/{post_id}")
          def delete_post(post_id: str):
              result = posts_collection.delete_one({"_id": ObjectId(post_id)})
              if result.deleted_count:
                  return {"message": "Post deleted successfully"}
              raise HTTPException(status_code=404, detail="Post not found")
          EOF
          
          uvicorn main:app --host 0.0.0.0 --port 3002
        env:
        - name: MONGODB_HOST
          valueFrom:
            configMapKeyRef:
              name: app-config
              key: MONGODB_HOST
        - name: MONGODB_USER
          valueFrom:
            secretKeyRef:
              name: db-secrets
              key: mongodb-user
        - name: MONGODB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: db-secrets
              key: mongodb-password
        ports:
        - containerPort: 3002
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
        livenessProbe:
          httpGet:
            path: /health
            port: 3002
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 3002
          initialDelaySeconds: 5
          periodSeconds: 5
---
apiVersion: v1
kind: Service
metadata:
  name: post-service
  namespace: blog-platform
spec:
  selector:
    app: post-service
  ports:
  - port: 80
    targetPort: 3002
  type: ClusterIP
```

### Phase 4: API Gateway 및 프론트엔드

#### Nginx API Gateway
```yaml
# api-gateway.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: nginx-config
  namespace: blog-platform
data:
  nginx.conf: |
    events {
        worker_connections 1024;
    }
    
    http {
        upstream user-service {
            server user-service.blog-platform.svc.cluster.local:80;
        }
        
        upstream post-service {
            server post-service.blog-platform.svc.cluster.local:80;
        }
        
        server {
            listen 80;
            
            location /api/users/ {
                proxy_pass http://user-service/api/users/;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
            }
            
            location /api/posts/ {
                proxy_pass http://post-service/api/posts/;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
            }
            
            location /health {
                return 200 "API Gateway is healthy\n";
                add_header Content-Type text/plain;
            }
        }
    }
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: api-gateway
  namespace: blog-platform
spec:
  replicas: 2
  selector:
    matchLabels:
      app: api-gateway
  template:
    metadata:
      labels:
        app: api-gateway
    spec:
      containers:
      - name: nginx
        image: nginx:1.21-alpine
        ports:
        - containerPort: 80
        volumeMounts:
        - name: nginx-config
          mountPath: /etc/nginx/nginx.conf
          subPath: nginx.conf
        resources:
          requests:
            memory: "64Mi"
            cpu: "50m"
          limits:
            memory: "128Mi"
            cpu: "100m"
      volumes:
      - name: nginx-config
        configMap:
          name: nginx-config
---
apiVersion: v1
kind: Service
metadata:
  name: api-gateway
  namespace: blog-platform
spec:
  selector:
    app: api-gateway
  ports:
  - port: 80
    targetPort: 80
  type: LoadBalancer
```

### Phase 5: HPA 및 모니터링 설정

#### HPA 설정
```yaml
# hpa.yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: user-service-hpa
  namespace: blog-platform
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: user-service
  minReplicas: 2
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
---
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: post-service-hpa
  namespace: blog-platform
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: post-service
  minReplicas: 2
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
```

## 🔄 8.3 CI/CD 파이프라인 구축

### GitHub Actions 워크플로우
```yaml
# .github/workflows/deploy.yml
name: Deploy to EKS

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  AWS_REGION: ap-northeast-2
  EKS_CLUSTER_NAME: my-first-cluster

jobs:
  deploy:
    name: Deploy
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout
      uses: actions/checkout@v3

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1

    - name: Build, tag, and push image to Amazon ECR
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: blog-platform
        IMAGE_TAG: ${{ github.sha }}
      run: |
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG

    - name: Update kube config
      run: aws eks update-kubeconfig --name $EKS_CLUSTER_NAME --region $AWS_REGION

    - name: Deploy to EKS
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: blog-platform
        IMAGE_TAG: ${{ github.sha }}
      run: |
        sed -i.bak "s|DOCKER_IMAGE|$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG|g" k8s/*.yaml
        kubectl apply -f k8s/
        kubectl rollout status deployment/user-service -n blog-platform
        kubectl rollout status deployment/post-service -n blog-platform
```

### ArgoCD를 사용한 GitOps (고급)
```yaml
# argocd-application.yaml
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: blog-platform
  namespace: argocd
spec:
  project: default
  source:
    repoURL: https://github.com/your-username/blog-platform-k8s
    targetRevision: HEAD
    path: k8s
  destination:
    server: https://kubernetes.default.svc
    namespace: blog-platform
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
    syncOptions:
    - CreateNamespace=true
```

## 📊 8.4 모니터링 및 로깅 시스템

### Prometheus 및 Grafana 설정
```bash
# Prometheus 설치
helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
helm install prometheus prometheus-community/kube-prometheus-stack \
  --namespace blog-monitoring \
  --create-namespace \
  --values prometheus-values.yaml
```

```yaml
# prometheus-values.yaml
prometheus:
  prometheusSpec:
    serviceMonitorSelectorNilUsesHelmValues: false
    podMonitorSelectorNilUsesHelmValues: false
    retention: 30d
    storageSpec:
      volumeClaimTemplate:
        spec:
          storageClassName: gp2
          accessModes: ["ReadWriteOnce"]
          resources:
            requests:
              storage: 50Gi

grafana:
  adminPassword: admin123
  service:
    type: LoadBalancer
  dashboardProviders:
    dashboardproviders.yaml:
      apiVersion: 1
      providers:
      - name: 'default'
        orgId: 1
        folder: ''
        type: file
        disableDeletion: false
        editable: true
        options:
          path: /var/lib/grafana/dashboards/default
```

### 커스텀 대시보드
```json
{
  "dashboard": {
    "title": "Blog Platform Dashboard",
    "panels": [
      {
        "title": "Service Response Time",
        "type": "graph",
        "targets": [
          {
            "expr": "histogram_quantile(0.95, sum(rate(http_request_duration_seconds_bucket[5m])) by (le, service))",
            "legendFormat": "{{ service }} - 95th percentile"
          }
        ]
      },
      {
        "title": "Request Rate",
        "type": "graph",
        "targets": [
          {
            "expr": "sum(rate(http_requests_total[5m])) by (service)",
            "legendFormat": "{{ service }}"
          }
        ]
      },
      {
        "title": "Error Rate",
        "type": "graph",
        "targets": [
          {
            "expr": "sum(rate(http_requests_total{status=~\"5..\"}[5m])) by (service) / sum(rate(http_requests_total[5m])) by (service)",
            "legendFormat": "{{ service }} error rate"
          }
        ]
      }
    ]
  }
}
```

## 🔒 8.5 보안 강화

### RBAC 설정
```yaml
# rbac.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: blog-platform-sa
  namespace: blog-platform
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: blog-platform
  name: blog-platform-role
rules:
- apiGroups: [""]
  resources: ["pods", "services", "configmaps", "secrets"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["apps"]
  resources: ["deployments"]
  verbs: ["get", "list", "watch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: blog-platform-rolebinding
  namespace: blog-platform
subjects:
- kind: ServiceAccount
  name: blog-platform-sa
  namespace: blog-platform
roleRef:
  kind: Role
  name: blog-platform-role
  apiGroup: rbac.authorization.k8s.io
```

### 네트워크 정책
```yaml
# network-policy.yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: blog-platform-netpol
  namespace: blog-platform
spec:
  podSelector: {}
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          name: blog-platform
    - namespaceSelector:
        matchLabels:
          name: blog-database
  egress:
  - to:
    - namespaceSelector:
        matchLabels:
          name: blog-database
  - to: []
    ports:
    - protocol: TCP
      port: 53
    - protocol: UDP
      port: 53
```

### Pod Security Standards
```yaml
# pod-security.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: blog-platform
  labels:
    pod-security.kubernetes.io/enforce: restricted
    pod-security.kubernetes.io/audit: restricted
    pod-security.kubernetes.io/warn: restricted
```

## 🧪 8.6 테스트 및 검증

### 부하 테스트
```bash
# Apache Bench를 사용한 부하 테스트
kubectl run load-test --image=httpd:2.4-alpine --rm -it --restart=Never -- /bin/sh

# Pod 내에서 실행
ab -n 1000 -c 10 http://api-gateway.blog-platform.svc.cluster.local/api/posts/

# 또는 외부에서 LoadBalancer IP로 테스트
ab -n 1000 -c 10 http://YOUR_LOADBALANCER_IP/api/posts/
```

### 장애 복구 테스트
```bash
# 특정 서비스 Pod 삭제하여 자동 복구 테스트
kubectl delete pod -l app=user-service -n blog-platform

# 노드 장애 시뮬레이션
kubectl drain NODE_NAME --ignore-daemonsets --delete-emptydir-data

# 데이터베이스 연결 장애 테스트
kubectl scale deployment postgres --replicas=0 -n blog-database
# 서비스 동작 확인 후 복구
kubectl scale deployment postgres --replicas=1 -n blog-database
```

## 🎯 8단계 완료 체크리스트

### 인프라 구성
- [ ] 네임스페이스 분리 및 기본 설정 완료
- [ ] ConfigMap과 Secret을 통한 설정 관리
- [ ] 데이터베이스 레이어 구축 (PostgreSQL, MongoDB, Redis)

### 마이크로서비스 구현
- [ ] User Service 배포 및 동작 확인
- [ ] Post Service 배포 및 동작 확인
- [ ] API Gateway를 통한 라우팅 설정
- [ ] 서비스 간 통신 확인

### 운영 기능
- [ ] HPA 설정 및 자동 스케일링 테스트
- [ ] 헬스 체크 및 프로브 설정
- [ ] 리소스 제한 및 요청 설정

### CI/CD 파이프라인
- [ ] GitHub Actions 워크플로우 설정
- [ ] 자동 빌드 및 배포 파이프라인 구축
- [ ] 롤링 업데이트 테스트

### 모니터링 및 보안
- [ ] Prometheus 및 Grafana 설치
- [ ] 커스텀 대시보드 생성
- [ ] RBAC 및 네트워크 정책 적용
- [ ] 보안 스캔 및 취약점 점검

### 테스트 및 검증
- [ ] 부하 테스트 실행
- [ ] 장애 복구 테스트 완료
- [ ] 전체 시스템 통합 테스트

## 💡 프로젝트 확장 아이디어

### 추가 기능 구현
1. **Comment Service**: Go로 댓글 서비스 구현
2. **File Upload Service**: 이미지 업로드 및 S3 연동
3. **Notification Service**: 실시간 알림 (WebSocket)
4. **Search Service**: Elasticsearch 기반 검색

### 고급 운영 기능
1. **Service Mesh**: Istio 도입으로 트래픽 관리
2. **Chaos Engineering**: Chaos Monkey 도입
3. **Multi-region Deployment**: 다중 리전 배포
4. **Backup & Disaster Recovery**: 백업 및 재해 복구 전략

## 🤔 문제 해결 가이드

### 일반적인 문제들
1. **서비스 간 통신 실패**: DNS 이름 확인, 네트워크 정책 점검
2. **데이터베이스 연결 실패**: Secret 설정, 네트워크 연결 확인
3. **HPA 동작 안 함**: Metrics Server 설치, 리소스 요청 설정 확인
4. **CI/CD 파이프라인 실패**: AWS 권한, ECR 설정 확인

### 디버깅 명령어
```bash
# 전체 시스템 상태 확인
kubectl get all --all-namespaces

# 특정 서비스 로그 확인
kubectl logs -f deployment/user-service -n blog-platform

# 서비스 간 연결 테스트
kubectl exec -it deployment/api-gateway -n blog-platform -- wget -qO- http://user-service/health

# 리소스 사용량 모니터링
kubectl top pods --all-namespaces
```

---

**축하합니다!** 🎉 실전 프로젝트를 통해 EKS와 쿠버네티스의 핵심 개념들을 모두 경험해보셨습니다. 이제 실제 프로덕션 환경에서 컨테이너 오케스트레이션을 구현할 수 있는 실력을 갖추셨습니다!